// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
'use strict';
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var machina = require("machina");
var azure_iot_common_1 = require("azure-iot-common");
var azure_iot_amqp_base_1 = require("azure-iot-amqp-base");
var uuid = require("uuid");
var dbg = require("debug");
var debug = dbg('azure-iot-device:twin');
var responseTopic = '$iothub/twin/res';
/**
 * @class        module:azure-iot-device-amqp.AmqpTwinReceiver
 * @classdesc    Acts as a receiver for device-twin traffic
 *
 * @param {Object} config   configuration object
 * @fires AmqpTwinReceiver#subscribed   an response or post event has been set up for listening.
 * @fires AmqpTwinReceiver#error    an error has occured
 * @fires AmqpTwinReceiver#response   a response message has been received from the service
 * @fires AmqpTwinReceiver#post a post message has been received from the service
 * @throws {ReferenceError} If client parameter is falsy.
 *
 */
/* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_005: [The `AmqpTwinReceiver` shall inherit from the `EventEmitter` class.] */
var AmqpTwinReceiver = (function (_super) {
    __extends(AmqpTwinReceiver, _super);
    function AmqpTwinReceiver(config, client) {
        var _this = _super.call(this) || this;
        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_003: [The `AmqpTwinReceiver` constructor shall accept a `config` object.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_004: [The `AmqpTwinReceiver` constructor shall throw `ReferenceError` if the `config` object is falsy.] */
        if (!config) {
            throw new ReferenceError('required parameter is missing');
        }
        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_001: [The `AmqpTwinReceiver` constructor shall accept a `client` object.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_002: [** The `AmqpTwinReceiver` constructor shall throw `ReferenceError` if the `client` object is falsy. **] */
        if (!client) {
            throw new ReferenceError('required parameter is missing');
        }
        _this._client = client;
        _this._internalOperations = {};
        _this._upstreamAmqpLink = null;
        _this._downstreamAmqpLink = null;
        _this._eventQueue = [];
        _this._eventQueueError = null;
        /*Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_007: [The endpoint argument for attacheReceiverLink shall be `/device/<deviceId>/twin/`.] */
        /*Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_009: [The endpoint argument for attacheSenderLink shall be `/device/<deviceId>/twin/`.] */
        _this._endpoint = azure_iot_common_1.endpoint.devicePath(config.deviceId) + '/twin/';
        _this._fsm = new machina.Fsm({
            namespace: 'amqp-twin-receiver',
            initialState: 'disconnected',
            states: {
                'disconnected': {
                    _onEnter: function () {
                        var headEvent;
                        while (headEvent = _this._eventQueue.shift()) {
                            if (headEvent.shift() === 'actual_sendTwinRequest') {
                                _this._rundown_sendTwinRequest.apply(_this, headEvent);
                            }
                        }
                        _this._eventQueueError = null;
                    },
                    handleNewListener: function (eventName) {
                        if ((eventName === AmqpTwinReceiver.responseEvent) || (eventName === AmqpTwinReceiver.postEvent)) {
                            _this._appendEventQueue();
                            _this._fsm.transition('connecting');
                        }
                    },
                    sendTwinRequest: function () {
                        _this._appendEventQueue();
                        _this._fsm.transition('connecting');
                    },
                    handleErrorEmit: function (err) {
                        debug('_handleError: error is: ' + JSON.stringify(err));
                        _this.emit(AmqpTwinReceiver.errorEvent, azure_iot_amqp_base_1.translateError('received an error from the amqp transport: ', err));
                    },
                    handleLinkDetach: function (detachObject) {
                        if (detachObject && detachObject.error) {
                            _this.emit(AmqpTwinReceiver.errorEvent, azure_iot_amqp_base_1.translateError('received an error from the amqp transport: ', detachObject.error));
                        }
                    }
                },
                'connecting': {
                    _onEnter: function () {
                        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_006: [When a listener is added for the `response` event, and the `post` event is NOT already subscribed, upstream and downstream links are established via calls to `attachReceiverLink` and `attachSenderLink`.] */
                        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_012: [When a listener is added for the `post` event, and the `response` event is NOT already subscribed, upstream and downstream links are established via calls to `attachReceiverLink` and `attachSenderLine`.] */
                        var linkCorrelationId = uuid.v4().toString();
                        _this._client.attachReceiverLink(_this._endpoint, _this._generateTwinLinkProperties(linkCorrelationId), function (receiverLinkError, receiverTransportObject) {
                            if (receiverLinkError) {
                                /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_022: [If an error occcurs on establishing the upstream or downstream link then the `error` event shall be emitted.] */
                                _this._fsm.handle('handleErrorEmit', receiverLinkError);
                            }
                            else {
                                _this._downstreamAmqpLink = receiverTransportObject;
                                _this._downstreamAmqpLink.on('detached', _this._onAmqpDetached.bind(_this));
                                _this._downstreamAmqpLink.on('errorReceived', _this._handleError.bind(_this));
                                _this._client.attachSenderLink(_this._endpoint, _this._generateTwinLinkProperties(linkCorrelationId), function (senderLinkError, senderTransportObject) {
                                    if (senderLinkError) {
                                        _this._fsm.handle('handleErrorEmit', senderLinkError);
                                    }
                                    else {
                                        _this._upstreamAmqpLink = senderTransportObject;
                                        _this._upstreamAmqpLink.on('detached', _this._onAmqpDetached.bind(_this));
                                        _this._upstreamAmqpLink.on('errorReceived', _this._handleError.bind(_this));
                                        _this._fsm.transition('connected');
                                    }
                                });
                            }
                        });
                    },
                    handleErrorEmit: function () {
                        _this._fsm.deferUntilTransition('disconnected');
                        _this._fsm.transition('disconnecting');
                    },
                    handleNewListener: function () {
                        _this._appendEventQueue();
                    },
                    handleRemoveListener: function () {
                        _this._appendEventQueue();
                    },
                    sendTwinRequest: function () {
                        _this._appendEventQueue();
                    }
                },
                'connected': {
                    _onEnter: function () {
                        _this._downstreamAmqpLink.on('message', _this._boundMessageHandler);
                        _this._handleHeadOfEventQueue();
                    },
                    actual_handleNewListener: function (eventName) {
                        if (eventName === AmqpTwinReceiver.responseEvent) {
                            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_011: [** Upon successfully establishing the upstream and downstream links the `subscribed` event shall be emitted from the twin receiver, with an argument object of {eventName: "response", transportObject: <object>}.] */
                            _this.emit(AmqpTwinReceiver.subscribedEvent, { 'eventName': AmqpTwinReceiver.responseEvent, 'transportObject': _this._upstreamAmqpLink });
                        }
                        else if (eventName === AmqpTwinReceiver.postEvent) {
                            //
                            // We need to send a PUT request upstream to enable notification of desired property changes
                            // from the cloud. Then we have to wait for the (hopefully) successful response to this request.
                            //
                            // Only at this point can we emit an successful subscribe to the agnostic twin code that is utilizing this receiver.
                            //
                            var correlationId = uuid.v4().toString();
                            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_013: [Upon receiving a successful response message with the correlationId of the `PUT`, the `subscribed` event shall be emitted from the twin receiver, with an argument object of {eventName: "post", transportObject: <object>}.] */
                            _this._internalOperations[correlationId] = function () {
                                _this.emit(AmqpTwinReceiver.subscribedEvent, { 'eventName': AmqpTwinReceiver.postEvent, 'transportObject': _this._upstreamAmqpLink });
                            };
                            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_019: [Upon successfully establishing the upstream and downstream links, a `PUT` request shall be sent on the upstream link with a correlationId set in the properties of the amqp message.] */
                            _this._sendTwinRequest('PUT', '/notifications/twin/properties/desired', { $rid: correlationId }, ' ');
                        }
                        _this._handleHeadOfEventQueue();
                    },
                    actual_handleRemoveListener: function (eventName) {
                        if ((eventName === AmqpTwinReceiver.postEvent) && events_1.EventEmitter.listenerCount(_this, AmqpTwinReceiver.postEvent) === 0) {
                            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_021: [When there is no more listeners for the `post` event, a `DELETE` request shall be sent on the upstream link with a correlationId set in the properties of the amqp message.] */
                            var correlationId = uuid.v4().toString();
                            _this._internalOperations[correlationId] = function () {
                                debug('Turned off desired property notification');
                            };
                            _this._sendTwinRequest('DELETE', '/notifications/twin/properties/desired', { $rid: correlationId }, ' ');
                        }
                        if ((events_1.EventEmitter.listenerCount(_this, AmqpTwinReceiver.postEvent) + events_1.EventEmitter.listenerCount(_this, AmqpTwinReceiver.responseEvent)) === 0) {
                            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_014: [When there are no more listeners for the `response` AND the `post` event, the upstream and downstream amqp links shall be closed via calls to `detachReceiverLink` and `detachSenderLink`.] */
                            _this._fsm.transition('disconnecting');
                        }
                        else {
                            _this._handleHeadOfEventQueue();
                        }
                    },
                    actual_sendTwinRequest: function (method, resource, properties, body, done) {
                        _this._sendTwinRequest(method, resource, properties, body, done);
                        _this._handleHeadOfEventQueue();
                    },
                    handleNewListener: function () {
                        _this._AppendOrHandleEvent();
                    },
                    handleRemoveListener: function () {
                        _this._AppendOrHandleEvent();
                    },
                    sendTwinRequest: function () {
                        _this._AppendOrHandleEvent();
                    },
                    handleErrorEmit: function () {
                        _this._fsm.deferUntilTransition('disconnected');
                        _this._fsm.transition('disconnecting');
                    },
                    handleLinkDetach: function (detachObject) {
                        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_023: [If a detach with error occurs on the upstream or the downstream link then the `error` event shall be emitted.] */
                        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_024: [If any detach occurs the other link will also be detached by the twin receiver.] */
                        _this._eventQueueError = (detachObject) ? detachObject.error : null;
                        _this._fsm.deferUntilTransition('disconnected');
                        _this._fsm.transition('disconnecting');
                    },
                    _onExit: function () {
                        _this._downstreamAmqpLink.removeListener('message', _this._boundMessageHandler);
                    }
                },
                'disconnecting': {
                    _onEnter: function () {
                        _this._client.detachSenderLink(_this._endpoint, function (detachSenderError, result) {
                            if (detachSenderError) {
                                debug('we received an error for the detach of the upstream link during the disconnect.  Moving on to the downstream link.');
                            }
                            _this._client.detachReceiverLink(_this._endpoint, function (detachReceiverError, result) {
                                if (detachReceiverError) {
                                    debug('we received an error for the detach of the downstream link during the disconnect.');
                                }
                                var possibleError = detachSenderError || detachReceiverError;
                                if (possibleError) {
                                    _this._fsm.handle('handleErrorEmit', possibleError);
                                }
                                _this._fsm.transition('disconnected');
                            });
                        });
                    },
                    handleErrorEmit: function () {
                        _this._fsm.deferUntilTransition('disconnected');
                    },
                    handleNewListener: function () {
                        _this._appendEventQueue();
                    },
                    handleRemoveListener: function () {
                        _this._appendEventQueue();
                    },
                    sendTwinRequest: function () {
                        _this._appendEventQueue();
                    }
                }
            }
        });
        _this.on('newListener', _this._handleNewListener.bind(_this));
        _this.on('removeListener', _this._handleRemoveListener.bind(_this));
        _this._boundMessageHandler = _this._onAmqpMessage.bind(_this); // need to save this so that calls to add & remove listeners can be matched by the EventEmitter.
        return _this;
    }
    /**
     * @method          module:azure-iot-device-amqp.Amqp#sendTwinRequest
     * @description     Send a device-twin specific messager to the IoT Hub instance
     *
     * @param {String}        method    name of the method to invoke ('PUSH', 'PATCH', etc)
     * @param {String}        resource  name of the resource to act on (e.g. '/properties/reported/') with beginning and ending slashes
     * @param {Object}        properties  object containing name value pairs for request properties (e.g. { 'rid' : 10, 'index' : 17 })
     * @param {String}        body  body of request
     * @param {Function}      done  the callback to be invoked when this function completes.
     *
     * @throws {ReferenceError}   One of the required parameters is falsy
     * @throws {ArgumentError}  One of the parameters is an incorrect type
     */
    AmqpTwinReceiver.prototype.sendTwinRequest = function (method, resource, properties, body, done) {
        this._fsm.handle('sendTwinRequest', method, resource, properties, body, done);
    };
    AmqpTwinReceiver.prototype._generateTwinLinkProperties = function (correlationId) {
        /*Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_010: [** The link options argument for attachSenderLink shall be:
             attach: {
                    properties: {
                      'com.microsoft:channel-correlation-id' : 'twin:<correlationId>',
                      'com.microsoft:api-version' : endpoint.apiVersion
                    },
                    sndSettleMode: 1,
                    rcvSettleMode: 0
                  } ] */
        /*Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_008: [The link options argument for attachReceiverLink shall be:
             attach: {
                    properties: {
                      'com.microsoft:channel-correlation-id' : 'twin:<correlationId>',
                      'com.microsoft:api-version' : endpoint.apiVersion
                    },
                    sndSettleMode: 1,
                    rcvSettleMode: 0
                  } ] */
        // Note that the settle mode hard coded values correspond to the defined constant values in the amqp10 specification.
        return {
            attach: {
                properties: {
                    'com.microsoft:channel-correlation-id': 'twin:' + correlationId,
                    'com.microsoft:api-version': azure_iot_common_1.endpoint.apiVersion
                },
                sndSettleMode: 1,
                rcvSettleMode: 0
            }
        };
    };
    AmqpTwinReceiver.prototype._handleNewListener = function (eventName) {
        this._fsm.handle('handleNewListener', eventName);
    };
    AmqpTwinReceiver.prototype._handleRemoveListener = function (eventName) {
        this._fsm.handle('handleRemoveListener', eventName);
    };
    AmqpTwinReceiver.prototype._onAmqpMessage = function (message) {
        //
        // The ONLY time we should see a message on the downstream link without a correlationId is if the message is a desired property delta update.
        //
        var correlationId = message.correlationId;
        if (correlationId) {
            this._onResponseMessage(message);
        }
        else if (message.hasOwnProperty('data')) {
            this._onDesiredPropertyDelta(message);
        }
        else {
            //
            // Can't be any message we know what to do with.  Just drop it on the floor.
            //
            debug('malformed response message received from service: ' + JSON.stringify(message));
        }
    };
    AmqpTwinReceiver.prototype._onResponseMessage = function (message) {
        debug('onResponseMessage: The downstream message is: ' + JSON.stringify(message));
        if (this._internalOperations[message.correlationId]) {
            var callback = this._internalOperations[message.correlationId];
            delete this._internalOperations[message.correlationId];
            callback();
        }
        else {
            //
            // The service sending back any response is an implied success.  Set status to 200.
            //
            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_016: [When a `response` event is emitted, the parameter shall be an object which contains `status`, `requestId` and `body` members.] */
            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_017: [The `requestId` value is aquired from the amqp message correlationId property in the response amqp message.] */
            /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_018: [the `body` parameter of the `response` event shall be the data of the received amqp message.] */
            var response = {
                'topic': responseTopic,
                'status': 200,
                '$rid': message.correlationId,
                'body': message.data
            };
            this.emit(AmqpTwinReceiver.responseEvent, response);
        }
    };
    AmqpTwinReceiver.prototype._onDesiredPropertyDelta = function (message) {
        /* Codes_SRS_NODE_DEVICE_AMQP_TWIN_06_020: [If there is a listener for the `post` event, a `post` event shall be emitted for each amqp message received on the downstream link that does NOT contain a correlation id, the parameter of the emit will be is the data of the amqp message.] */
        debug('onPostMessage: The downstream message is: ' + JSON.stringify(message));
        this.emit(AmqpTwinReceiver.postEvent, message.data);
    };
    AmqpTwinReceiver.prototype._onAmqpDetached = function (detachObject) {
        this._fsm.handle('handleLinkDetach', detachObject);
    };
    AmqpTwinReceiver.prototype._handleError = function (err) {
        this._fsm.handle('handleErrorEmit', err);
    };
    AmqpTwinReceiver.prototype._safeCallback = function (callback, error, result) {
        if (callback) {
            process.nextTick(function () { return callback(error, result); });
        }
    };
    AmqpTwinReceiver.prototype._appendEventQueue = function () {
        var argArray = [];
        argArray.push('actual_' + this._fsm.currentActionArgs[0].inputType);
        var i = 1;
        for (; i <= this._fsm.currentActionArgs.length - 1; i++) {
            argArray.push(this._fsm.currentActionArgs[i]);
        }
        this._eventQueue.push(argArray);
    };
    AmqpTwinReceiver.prototype._handleHeadOfEventQueue = function () {
        var head = this._eventQueue.shift();
        if (head) {
            this._fsm.handle.apply(this._fsm, head);
        }
    };
    AmqpTwinReceiver.prototype._AppendOrHandleEvent = function () {
        this._appendEventQueue();
        if (this._eventQueue.length === 1) {
            this._handleHeadOfEventQueue();
        }
    };
    AmqpTwinReceiver.prototype._isString = function (obj) {
        return (typeof obj === 'string');
    };
    AmqpTwinReceiver.prototype._isNumber = function (obj) {
        return (typeof obj === 'number');
    };
    AmqpTwinReceiver.prototype._isBoolean = function (obj) {
        return (typeof obj === 'boolean');
    };
    AmqpTwinReceiver.prototype._rundown_sendTwinRequest = function (method, resource, properties, body, done) {
        if (!!done && (typeof done === 'function')) {
            done(this._eventQueueError || new Error('Link Detached'));
        }
    };
    AmqpTwinReceiver.prototype._sendTwinRequest = function (method, resource, properties, body, done) {
        var _this = this;
        /* Codes_SRS_NODE_DEVICE_AMQP_06_012: [The `sendTwinRequest` method shall not throw `ReferenceError` if the `done` callback is falsy.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_06_013: [The `sendTwinRequest` method shall throw an `ReferenceError` if the `method` argument is falsy.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_06_014: [The `sendTwinRequest` method shall throw an `ReferenceError` if the `resource` argument is falsy.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_06_015: [The `sendTwinRequest` method shall throw an `ReferenceError` if the `properties` argument is falsy.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_06_016: [The `sendTwinRequest` method shall throw an `ReferenceError` if the `body` argument is falsy.] */
        if (!method || !resource || !properties || !body) {
            throw new ReferenceError('required parameter is missing');
        }
        /* Codes_SRS_NODE_DEVICE_AMQP_06_017: [The `sendTwinRequest` method shall throw an `ArgumentError` if the `method` argument is not a string.] */
        /* Codes_SRS_NODE_DEVICE_AMQP_06_018: [The `sendTwinRequest` method shall throw an `ArgumentError` if the `resource` argument is not a string.] */
        if (!this._isString(method) || !this._isString(resource)) {
            throw new azure_iot_common_1.errors.ArgumentError('required string parameter is not a string');
        }
        /* Codes_SRS_NODE_DEVICE_AMQP_06_019: [The `sendTwinRequest` method shall throw an `ArgumentError` if the `properties` argument is not a an object.] */
        if (!(properties instanceof Object)) {
            throw new azure_iot_common_1.errors.ArgumentError('required properties parameter is not an object');
        }
        var amqpMessage = new azure_iot_amqp_base_1.AmqpMessage();
        amqpMessage.messageAnnotations = {};
        amqpMessage.properties = {};
        //
        // Amqp requires that the resource designation NOT be terminated by a slash.  The agnostic twin client was terminating the
        // resources with a slash which worked just dandy for MQTT.
        //
        // We need to cut off a terminating slash.  If we cut off a terminating slash and the length of resource is zero then simply
        // don't specify a resource.
        //
        // What if the caller specifies a "//" resource?  Don't do that.
        //
        // So you'll note that in this case "/" sent down will be turned into an empty string.  So why not
        // simply send down "" to begin with?  Because you can't send a falsy parameter.
        //
        /* Codes_SRS_NODE_DEVICE_AMQP_06_020: [The `method` argument shall be the value of the amqp message `operation` annotation.] */
        amqpMessage.messageAnnotations.operation = method;
        var localResource = resource;
        /* Codes_SRS_NODE_DEVICE_AMQP_06_031: [If the `resource` argument terminates in a slash, the slash shall be removed from the annotation.] */
        if (localResource.substr(localResource.length - 1, 1) === '/') {
            localResource = localResource.slice(0, localResource.length - 1);
        }
        /* Codes_SRS_NODE_DEVICE_AMQP_06_039: [If the `resource` argument length is zero (after terminating slash removal), the resource annotation shall not be set.] */
        if (localResource.length > 0) {
            /* Codes_SRS_NODE_DEVICE_AMQP_06_021: [The `resource` argument shall be the value of the amqp message `resource` annotation.] */
            amqpMessage.messageAnnotations.resource = localResource;
        }
        /*Codes_SRS_NODE_DEVICE_AMQP_06_032: [If the `operation` argument is `PATCH`, the `version` annotation shall be set to `null`.] */
        if (method === 'PATCH') {
            amqpMessage.messageAnnotations.version = null;
        }
        Object.keys(properties).forEach(function (key) {
            /* Codes_SRS_NODE_DEVICE_AMQP_06_028: [The `sendTwinRequest` method shall throw an `ArgumentError` if any members of the `properties` object fails to serialize to a string.] */
            if (!_this._isString(properties[key]) && !_this._isNumber(properties[key]) && !_this._isBoolean(properties[key])) {
                throw new azure_iot_common_1.errors.ArgumentError('required properties object has non-string properties');
            }
            /* Codes_SRS_NODE_DEVICE_AMQP_06_022: [All properties, except $rid, shall be set as the part of the properties map of the amqp message.] */
            /* Codes_SRS_NODE_DEVICE_AMQP_06_023: [The $rid property shall be set as the `correlationId` in the properties map of the amqp message.] */
            if (key === '$rid') {
                amqpMessage.properties.correlationId = properties[key].toString();
            }
            else {
                amqpMessage.properties[key] = properties[key];
            }
        });
        /* Codes_SRS_NODE_DEVICE_AMQP_06_024: [The `body` shall be value of the body of the amqp message.] */
        amqpMessage.body = body.toString();
        /* Codes_SRS_NODE_DEVICE_AMQP_06_025: [The amqp message will be sent upstream to the IoT Hub via the amqp client `send`.]*/
        this._upstreamAmqpLink.send(amqpMessage)
            .then(function (state) {
            debug(' amqp-twin-receiver: Good dispostion on the amqp message send: ' + JSON.stringify(state));
            _this._safeCallback(done, null, new azure_iot_common_1.results.MessageEnqueued(state));
            return null;
        })
            .catch(function (err) {
            debug(' amqp-twin-receiver: Bad dispostion on the amqp message send: ' + err);
            _this._safeCallback(done, azure_iot_amqp_base_1.translateError('Unable to send Twin message', err));
        });
    };
    return AmqpTwinReceiver;
}(events_1.EventEmitter));
AmqpTwinReceiver.errorEvent = 'error';
AmqpTwinReceiver.responseEvent = 'response';
AmqpTwinReceiver.postEvent = 'post';
AmqpTwinReceiver.subscribedEvent = 'subscribed';
exports.AmqpTwinReceiver = AmqpTwinReceiver;
//# sourceMappingURL=amqp_twin_receiver.js.map